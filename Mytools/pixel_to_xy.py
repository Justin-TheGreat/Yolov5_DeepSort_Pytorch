# -*- coding: utf-8 -*-
"""Pixel_to_XY.ipynb

Automatically generated by Colaboratory.

"""
# Use your own knowledge to calibrate!!
import math

def pixel_to_xy(cen_x,cen_y,img):
   # units in meter. There are x-1 elements,(right now is ten zones).
   # add this number to the coordinate. Note that every element is the sum of all previous elements
  r1 = [0,0.555, 1.915, 4.145, 12.21]
  r2 = [0,0.545, 1.68, 3.865, 10.235]
  r3 = [0,0.555, 1.625, 3.66, 7.83]
  r4 = [0,0.615, 1.67, 3.4, 7.065]
  r5 = [0,0.675, 1.69, 3.115, 6.495]
# units of ratio is meter/pixel

# calibrate horix_ratio
   #r1
  if cen_y > int(img.shape[0]*0.8) and cen_y <= int(img.shape[0]*0.9) and cen_x > int(img.shape[1]*0.5) and  cen_x <= int(img.shape[1]*0.6):
    r = 1.2 + r1[0] + abs(cen_y - img.shape[0]*0.9) * 0.011562500000000002
    theta = 0 + 0.2265625 * abs(cen_x - img.shape[1]*0.6) + 90
  elif cen_y > int(img.shape[0] * 0.7) and cen_y <= int(img.shape[0] * 0.8) and cen_x > int(img.shape[1] * 0.5) and cen_x <= int(img.shape[1] * 0.6):
    r = 1.2 + r1[1] + abs(cen_y - img.shape[0] * 0.8) * 0.028333333333333332
    theta = 0 + 0.2265625 * abs(cen_x - img.shape[1] * 0.6) + 90
  elif cen_y > int(img.shape[0] * 0.6) and cen_y <= int(img.shape[0] * 0.7) and cen_x > int(img.shape[1] * 0.5) and cen_x <= int(img.shape[1] * 0.6):
    r = 1.2 + r1[2] + abs(cen_y - img.shape[0] * 0.7) * 0.04645833333333333
    theta = 0 + 0.2265625 * abs(cen_x - img.shape[1] * 0.6) + 90
  elif cen_y > int(img.shape[0] * 0.5) and cen_y <= int(img.shape[0] * 0.6) and cen_x > int(img.shape[1] * 0.5) and cen_x <= int(img.shape[1] * 0.6):
    r = 1.2 + r1[3] + abs(cen_y - img.shape[0] * 0.6) * 0.1680208333
    theta = 0 + 0.2265625 * abs(cen_x - img.shape[1] * 0.6) + 90
  #r2
  elif cen_y > int(img.shape[0] * 0.8) and cen_y <= int(img.shape[0] * 0.9) and cen_x > int(img.shape[1] * 0.4) and cen_x <= int(img.shape[1] * 0.5):
    r = 1.2 + r2[0] + abs(cen_y - img.shape[0] * 0.9) * 0.01135416666666666666666666666667
    theta = 14.5 + 0.2546875 * abs(cen_x - img.shape[1] * 0.5) + 90
  elif cen_y > int(img.shape[0] * 0.7) and cen_y <= int(img.shape[0] * 0.8) and cen_x > int(img.shape[1] * 0.4) and cen_x <= int(img.shape[1] * 0.5):
    r = 1.2 + r2[1] + abs(cen_y - img.shape[0] * 0.8) * 0.02364583333333333333333333333333
    theta = 14.5 + 0.2546875 * abs(cen_x - img.shape[1] * 0.5) + 90
  elif cen_y > int(img.shape[0] * 0.6) and cen_y <= int(img.shape[0] * 0.7) and cen_x > int(img.shape[1] * 0.4) and cen_x <= int(img.shape[1] * 0.5):
    r = 1.2 + r2[2] + abs(cen_y - img.shape[0] * 0.7) * 0.04552083333333333333333333333333
    theta = 14.5 + 0.2546875 * abs(cen_x - img.shape[1] * 0.5) + 90
  elif cen_y > int(img.shape[0] * 0.5) and cen_y <= int(img.shape[0] * 0.6) and cen_x > int(img.shape[1] * 0.4) and cen_x <= int(img.shape[1] * 0.5):
    r = 1.2 + r2[3] + abs(cen_y - img.shape[0] * 0.6) * 0.13270833333333333333333333333333
    theta = 14.5 + 0.2546875 * abs(cen_x - img.shape[1] * 0.5) + 90
  #r3
  elif cen_y > int(img.shape[0] * 0.8) and cen_y <= int(img.shape[0] * 0.9) and cen_x > int(img.shape[1] * 0.3) and cen_x <= int(img.shape[1] * 0.4):
    r = 1.2 + r3[0] + abs(cen_y - img.shape[0] * 0.9) * 0.011458333
    theta = 30.8 + 0.2078125 * abs(cen_x - img.shape[1] * 0.4) + 90
  elif cen_y > int(img.shape[0] * 0.7) and cen_y <= int(img.shape[0] * 0.8) and cen_x > int(img.shape[1] * 0.3) and cen_x <= int(img.shape[1] * 0.4):
    r = 1.2 + r3[1] + abs(cen_y - img.shape[0] * 0.8) * 0.022291667
    theta = 30.8 + 0.2078125 * abs(cen_x - img.shape[1] * 0.4) + 90
  elif cen_y > int(img.shape[0] * 0.6) and cen_y <= int(img.shape[0] * 0.7) and cen_x > int(img.shape[1] * 0.3) and cen_x <= int(img.shape[1] * 0.4):
    r = 1.2 + r3[2] + abs(cen_y - img.shape[0] * 0.7) * 0.042395833
    theta = 30.8 + 0.2078125 * abs(cen_x - img.shape[1] * 0.4) + 90
  elif cen_y > int(img.shape[0] * 0.5) and cen_y <= int(img.shape[0] * 0.6) and cen_x > int(img.shape[1] * 0.3) and cen_x <= int(img.shape[1] * 0.4):
    r = 1.2 + r3[3] + abs(cen_y - img.shape[0] * 0.6) * 0.086875
    theta = 30.8 + 0.2078125 * abs(cen_x - img.shape[1] * 0.4) + 90
  #r4
  elif cen_y > int(img.shape[0] * 0.8) and cen_y <= int(img.shape[0] * 0.9) and cen_x > int(img.shape[1] * 0.2) and cen_x <= int(img.shape[1] * 0.3):
    r = 1.2 + r4[0] + abs(cen_y - img.shape[0] * 0.9) * 0.012916666666666668
    theta = 44.1 + 0.2078125 * abs(cen_x - img.shape[1] * 0.3) + 90
  elif cen_y > int(img.shape[0] * 0.7) and cen_y <= int(img.shape[0] * 0.8) and cen_x > int(img.shape[1] * 0.2) and cen_x <= int(img.shape[1] * 0.3):
    r = 1.2 + r4[1] + abs(cen_y - img.shape[0] * 0.8) * 0.02197916666666667
    theta = 44.1 + 0.2078125 * abs(cen_x - img.shape[1] * 0.3) + 90
  elif cen_y > int(img.shape[0] * 0.6) and cen_y <= int(img.shape[0] * 0.7) and cen_x > int(img.shape[1] * 0.2) and cen_x <= int(img.shape[1] * 0.3):
    r = 1.2 + r4[2] + abs(cen_y - img.shape[0] * 0.7) * 0.036041666666666666
    theta = 44.1 + 0.2078125 * abs(cen_x - img.shape[1] * 0.3) + 90
  elif cen_y > int(img.shape[0] * 0.5) and cen_y <= int(img.shape[0] * 0.6) and cen_x > int(img.shape[1] * 0.2) and cen_x <= int(img.shape[1] * 0.3):
    r = 1.2 + r4[3] + abs(cen_y - img.shape[0] * 0.6) * 0.07635416666666667
    theta = 44.1 + 0.2078125 * abs(cen_x - img.shape[1] * 0.3) + 90
  #r5
  elif cen_y > int(img.shape[0] * 0.8) and cen_y <= int(img.shape[0] * 0.9) and cen_x > int(img.shape[1] * 0.1) and cen_x <= int(img.shape[1] * 0.2):
    r = 1.2 + r5[0] + abs(cen_y - img.shape[0] * 0.9) * 0.0140625
    theta = 53.5 + 0.146875 * abs(cen_x - img.shape[1] * 0.2) + 90
  elif cen_y > int(img.shape[0] * 0.7) and cen_y <= int(img.shape[0] * 0.8) and cen_x > int(img.shape[1] * 0.1) and cen_x <= int(img.shape[1] * 0.2):
    r = 1.2 + r5[1] + abs(cen_y - img.shape[0] * 0.8) * 0.021145833
    theta = 53.5 + 0.146875 * abs(cen_x - img.shape[1] * 0.2) + 90
  elif cen_y > int(img.shape[0] * 0.6) and cen_y <= int(img.shape[0] * 0.7) and cen_x > int(img.shape[1] * 0.1) and cen_x <= int(img.shape[1] * 0.2):
    r = 1.2 + r5[2] + abs(cen_y - img.shape[0] * 0.7) * 0.0296875
    theta = 53.5 + 0.146875 * abs(cen_x - img.shape[1] * 0.2) + 90
  elif cen_y > int(img.shape[0] * 0.5) and cen_y <= int(img.shape[0] * 0.6) and cen_x > int(img.shape[1] * 0.1) and cen_x <= int(img.shape[1] * 0.2):
    r = 1.2 + r5[3] + abs(cen_y - img.shape[0] * 0.6) * 0.070416667
    theta = 53.5 + 0.146875 * abs(cen_x - img.shape[1] * 0.2) + 90
  else:
    return None

# convert cylindrical coordinate to Cartesian coordinate

  rad = theta * math.pi/180
  x = r * math.cos(rad)
  y = r * math.sin(rad)

  target = [x,y]
  return target
